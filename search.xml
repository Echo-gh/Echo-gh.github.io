<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>论文记录 Co-fusion Real-time segmentation, tracking and fusion of multiple objects</title>
    <url>/2024/01/27/Co-fusion/</url>
    <content><![CDATA[<h1 id="3-Overview-of-our-Method"><a href="#3-Overview-of-our-Method" class="headerlink" title="3 Overview of our Method"></a>3 Overview of our Method</h1><p>Co-Fusion 是一个可以<strong>实时处理</strong>每一帧输入图片的RGB-D SLAM 系统，本系统为场景中每一个分割的物体<strong>存储模型</strong>，而且可以<strong>独立跟踪</strong>它们的运动，每个模型是由<strong>一组3D 点</strong>构成的。本系统维护两组物体模型：当前在视野中可见的<strong>active 模型</strong>，以及曾经观测到的模型，但是目前不在视野中，记为<strong>inactive 模型</strong>。本系统的框架如Fig. 2所示，在初始化阶段，场景只包含一个active 模型——<strong>背景</strong>，初始化完成后，按照Fig .2的流程处理每一帧图片。</p>
<span id="more"></span>
<p><img src="/2024/01/27/Co-fusion/overview.png" alt="overview" title="Overview"></p>
<p><strong>tracking</strong> 与 <strong>fusion</strong> 步骤是在GPU 上完成的，而<strong>segmentation</strong> 步骤是在CPU 上完成的。</p>
<h2 id="3-1-Tracking"><a href="#3-1-Tracking" class="headerlink" title="3.1 Tracking"></a><strong>3.1 Tracking</strong></h2><p>在当前帧中跟踪每一个active 模型的6DOF 位姿，通过最小化每个模型独立的目标方程来实现，该目标方程包含：</p>
<ul>
<li><strong>几何误差</strong>：基于稠密的iterative closest point (ICP) 对齐；</li>
<li><strong>光度误差</strong>：基于当前帧和存储的3D 模型之间的颜色差异。</li>
</ul>
<h2 id="3-2-Segmentation"><a href="#3-2-Segmentation" class="headerlink" title="3.2 Segmentation"></a><strong>3.2 Segmentation</strong></h2><p>该阶段将当前帧中的每一个像素与某个active 模型/物体联系起来，有两种手段来实现该过程：motion 以及 semantic labels。</p>
<h3 id="3-2-1-Motion-segmentation"><a href="#3-2-1-Motion-segmentation" class="headerlink" title="3.2.1 Motion segmentation"></a>3.2.1 Motion segmentation</h3><p>将运动分割构建为一个使用全连接的Conditional Random Field (CRF) 解决的<strong>分类问题</strong>，可在CPU 上实时处理。当将一个像素与一个运动模型联系起来时，unary potentials 编码一个几何 <strong>ICP 损失函数</strong>。</p>
<h3 id="3-2-2-Multi-class-image-segmentation"><a href="#3-2-2-Multi-class-image-segmentation" class="headerlink" title="3.2.2 Multi-class image segmentation"></a>3.2.2 Multi-class image segmentation</h3><p>利用基于<strong>深度学习</strong>的方法实现像素级的语义分割，作为动作分割的备选方案。</p>
<h2 id="3-3-Fusion"><a href="#3-3-Fusion" class="headerlink" title="3.3 Fusion"></a>3.3 Fusion</h2><p>本系统使用surfel-based 融合方法，利用新估计的6DOF 位姿将属于某个模型的点更新至其active 模型。其中，每个模型是由一个sufel 列表构成的，$\mathcal{M}_m^s \in (\mathbf{p}\in \mathbb{R}^3, \mathbf{n}\in \mathbb{R}^3, \mathbf{c}\in \mathbb{N}^3, w \in \mathbb{R}, r \in \mathbb{R}, \mathbf{t}\in \mathbb{R}^2)$ ，分别表示位置、法向量、颜色、权重、半径以及两个时间戳。</p>
<p>为了解决<strong>动态物体</strong>的跟踪问题，本系统使用 $\mathcal{T}_t = \{\mathbf{T}_{tm}()\}$ 来表示每个active 模型 $\mathcal{M}_m$ 在时间 t 相对于全局参考坐标系的位姿转换几何，即 $\mathbf{T}_{tm}$ 表示时间 t 时模型 $\mathcal{M}_m$ 的全局位姿。特别地，作者使用 $\mathbf{T}_{tb}$ 来表示<strong>背景模型</strong>的位姿转换。</p>
<h1 id="5-Tracking-Active-Models"><a href="#5-Tracking-Active-Models" class="headerlink" title="5 Tracking Active Models"></a>5 Tracking Active Models</h1><p>对于时间t 的图像帧中的每一个active 模型  $\mathcal{M}_m$ ，系统通过配准<strong>当前的深度图</strong>和<strong>前一帧的深度图</strong>（通过将存储的3D 模型利用t-1 的估计位姿进行投影而获取）来跟踪其全局位姿 $\mathbf{T}_{tm}$ ，对每一个active 模型进行<strong>独立优化和跟踪</strong>。</p>
<h2 id="5-1-Energy"><a href="#5-1-Energy" class="headerlink" title="5.1 Energy"></a>5.1 Energy</h2><p>误差项包含<strong>ICP 几何误差</strong>和<strong>光度误差</strong>，其中光度误差是由预测的图片（将之前帧中存储的3D 模型投影而获取）与当前图片的<strong>颜色差异</strong>构成，</p>
<p><img src="/2024/01/27/Co-fusion/formula1.png" alt="formula1"></p>
<h2 id="5-2-Geometry-Term"><a href="#5-2-Geometry-Term" class="headerlink" title="5.2 Geometry Term"></a>5.2 Geometry Term</h2><p>ICP 几何误差定义为以下两者之间的误差：</p>
<ul>
<li>当前帧深度图的<strong>逆向投影</strong>3D 点；</li>
<li>前一帧t-1 <strong>预测</strong>的深度图。</li>
</ul>
<p><img src="/2024/01/27/Co-fusion/formula2.png" alt="formula2"></p>
<p>其中，$\mathbf{v}_t^i$ 是当前帧深度图 $\mathcal{D}_t$ 中第i 个点的反向映射3D 点；$\mathbf{v}^i, \mathbf{n}^i$ 分别是t-1 时刻<strong>预测的深度图</strong>中模型m 第i 个点的反向映射点以及其法向量；$\mathbf{T}_m$ 是将前一帧与当前帧的模型m 对齐的<strong>位姿转换</strong>。</p>
<h2 id="5-3-Photometric-Color-Term"><a href="#5-3-Photometric-Color-Term" class="headerlink" title="5.3 Photometric Color Term"></a>5.3 Photometric Color Term</h2><p>在给定(1)当前深度图、(2)每个active 模型的3D 几何估计，以及(3)将每个模型与前一帧对齐的位姿转换关系，即可将当前场景合成为一个与前一帧对齐的虚拟投影，进而，跟踪问题就变为了当前帧与合成的虚拟投影之间的<strong>光度配准</strong>问题：</p>
<p><img src="/2024/01/27/Co-fusion/formula3.png" alt="formula3"></p>
<p>其中，$\mathbf{T}_m$ 是将前一帧与当前帧的模型m 对齐的<strong>位姿转换</strong>；$\mathbf{I}_{t-1}()$ 表示提供模型在前一帧上顶点的颜色参数。</p>
<p>为了鲁棒性和效率，本优化使用一个<strong>4层的空间金字塔</strong>来集成到一个<strong>由粗到细</strong>的方法中，并在GPU 中完成运算。</p>
<h1 id="6-Motion-Segmentation"><a href="#6-Motion-Segmentation" class="headerlink" title="6 Motion Segmentation"></a>6 Motion Segmentation</h1><p>在跟踪步骤之后，在t 时刻有 $M_t$ 个新的位姿转换 $\{\mathbf{T}_{tm}\}$ ，来描述每个active 模型相对于全局坐标系的绝对位姿；接下来作者将帧t 的运动分割问题构建为一个<strong>分类标记问题</strong>，而标签为 $M_t$ 个位姿转换 $\{\mathbf{T}_{tm}\}$ ，作者将 $M_t+1$ 种可能分配到<strong>每一个像素</strong>中，即 $\mathcal{l} \in \mathcal{L}_t = \{1, …, |M_t|+1\}$ ，除了 $M_t$ 个位姿转换 $\{\mathbf{T}_{tm}\}$外还包含一个<strong>外点标签</strong> $\mathcal{l}_{|M_t|+1}$ 。</p>
<p>为了可以在CPU上实施完成分割步骤，系统首先将当前帧分割为SLIC 超像素，并在超像素级别上进行分类标记，超像素的位置、颜色与深度由从属的所有像素均值得到。代价函数如下所示：</p>
<p><img src="/2024/01/27/Co-fusion/formula4.png" alt="formula4"></p>
<p>其中，i 和 j 图片中超像素的索引（从1到S）。</p>
<h2 id="6-1-The-Unary-Potentials"><a href="#6-1-The-Unary-Potentials" class="headerlink" title="6.1 The Unary Potentials"></a>6.1 The Unary Potentials</h2><p>对于 $\psi_u(x_i)$ 表示为超像素 $s_i$ 分配标签为 $x_i$ 的代价，对于运动分割模式，该代价为<strong>ICP 几何对齐损失函数</strong>（式 2）。</p>
<h2 id="6-2-The-Pairwise-Potentials"><a href="#6-2-The-Pairwise-Potentials" class="headerlink" title="6.2 The Pairwise Potentials"></a>6.2 The Pairwise Potentials</h2><p>对于 $\psi_p(x_i, x_j)$ 可表示为：</p>
<p><img src="/2024/01/27/Co-fusion/formula5.png" alt="formula5"></p>
<p>其中，$\mu(x_i, x_j)$ 惩罚<strong>临近像素标签不同</strong>的情况；$k_m(f_i, f_j)$ 测量像素外观之间的<strong>相似度</strong>，代表的含义是：两个超像素的<strong>特征向量</strong>之间的距离较小时应具有相同的标签，所谓的特征向量 $f_i$  包含2D 位置、RGB 颜色以及深度值。</p>
<h2 id="6-3-Post-processing"><a href="#6-3-Post-processing" class="headerlink" title="6.3 Post-processing"></a>6.3 Post-processing</h2><p>在分割之后，采用一系列<strong>后处理步骤</strong>来获取更为鲁棒的结果：</p>
<ol>
<li>对具有相似位姿转换关系的模型进行<strong>融合操作</strong>；</li>
<li>抑制相同标签中除最大之外的所有区域来保证不连接区域的<strong>独立建模</strong>；</li>
<li>小于一定阈值的区域被<strong>舍弃</strong>。</li>
</ol>
<h2 id="6-4-Addition-of-New-Models"><a href="#6-4-Addition-of-New-Models" class="headerlink" title="6.4 Addition of New Models"></a>6.4 Addition of New Models</h2><p>一个区域内的外点数量若大于总像素数的3%，则判定该物体为一个新物体；若该新物体的部分几何结构已存在于地图中，会对重复的构建进行剔除。</p>
<p>如果一个物体消失在视野中，并在一定帧内不再出现，则将该模型添加进inactive 列表中。</p>
<h1 id="7-Object-Instance-Segmentation"><a href="#7-Object-Instance-Segmentation" class="headerlink" title="7 Object Instance Segmentation"></a>7 Object Instance Segmentation</h1><p>使用实例分割网络SharpMask 进行物体语义信息的获取。</p>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>Dynamic SLAM</category>
      </categories>
      <tags>
        <tag>Dynamic SLAM</tag>
        <tag>SLAM</tag>
        <tag>Semantic</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu系统安装</title>
    <url>/2024/01/26/Ubuntu-setup/</url>
    <content><![CDATA[<h1 id="1-系统盘制作"><a href="#1-系统盘制作" class="headerlink" title="1 系统盘制作"></a>1 系统盘制作</h1><p>推荐使用 Rufus 这个软件进行制作：</p>
<span id="more"></span>
<p><img src="/2024/01/26/Ubuntu-setup/rufus.png" alt="rufus" title="rufus设置界面"></p>
<h1 id="2-进入BIOS更改启动顺序"><a href="#2-进入BIOS更改启动顺序" class="headerlink" title="2 进入BIOS更改启动顺序"></a>2 进入BIOS更改启动顺序</h1><p>将制作好的U盘插入电脑，启动电脑进入BIOS，设置第一启动项为U盘启动，保存BIOS设置并重新启动电脑，启动后选择”Try or install Ubuntu”选项，注意，此时可能会出现电脑黑屏的情况，但是屏幕是点亮的、鼠标有灯效，证明确实进入了安装系统，但是由于Ubuntu显卡驱动的问题，此时需要进行额外设置：</p>
<ol>
<li><p>重新启动电脑，在光标选择”Try or install Ubuntu”选项后，不要点击Enter键，而是点击”e”键进入命令行编辑模型；</p>
</li>
<li><p>删除”quite splash”后的”—-“，并添加”nomodeset”（依照不同显卡进行不同显卡驱动选项的添加，对于Nvidia显卡，添加nomodeset）；</p>
</li>
<li><p>然后，点击”F10”开始安装，此时电脑屏幕会正常。</p>
</li>
</ol>
<p>值得注意的是，装机成功重启后可能也会出现黑屏的情况（本人没有遇到），此时应在开机后点击”e”键，同样找到”quite splash” 并在后面添加”nomodeset”，按”F10”启动系统 ，进去系统之后编辑”/etc/default/grub”这个文件，具体操作在此不做赘述，可参考<a href="https://blog.csdn.net/qq_32285693/article/details/118900765">该文章</a>。</p>
<h1 id="3-设置硬盘分区"><a href="#3-设置硬盘分区" class="headerlink" title="3 设置硬盘分区"></a>3 设置硬盘分区</h1><p>本人想将之前的双系统进行清空，但又不想使用默认设置，故选择”something else”：</p>
<ol>
<li>清空之前双系统的所有磁盘空间，将硬盘全置为free；</li>
<li>根据个人需求设置硬盘分区，以下是重点部分，本人设置情况如下所示（<strong>注意分区类型</strong>）：</li>
</ol>
<p><img src="/2024/01/26/Ubuntu-setup/disk_set.png" alt="磁盘分区设置" title="磁盘分区设置"></p>
<p>具体空间分配可根据个人使用习惯和硬盘大小进行设置，值得注意的是，<strong>EFI 分区一定是第一个设置的！！！</strong></p>
<h1 id="4-Ubuntu设置"><a href="#4-Ubuntu设置" class="headerlink" title="4 Ubuntu设置"></a>4 Ubuntu设置</h1><p>进入Ubuntu系统后的设置不再赘述。</p>
]]></content>
      <categories>
        <category>开发环境搭建</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc、g++版本管理</title>
    <url>/2024/01/26/gcc-g/</url>
    <content><![CDATA[<p>本文主要参考<a href="https://zhuanlan.zhihu.com/p/261001751">文章</a>。</p>
<h2 id="1-版本查看"><a href="#1-版本查看" class="headerlink" title="1 版本查看"></a>1 版本查看</h2><p>对系统中的现有gcc、g++版本进行查看，安装所需版本：</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看当前版本</span></span><br><span class="line">gcc -v</span><br><span class="line">g++ -v</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看系统已安装版本</span></span><br><span class="line"><span class="built_in">ls</span> /usr/bin/gcc*</span><br><span class="line"><span class="built_in">ls</span> /usr/bin/g++*</span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装新版本</span></span><br><span class="line">sudo apt install gcc-11</span><br><span class="line">sudo apt install g++-11</span><br></pre></td></tr></table></figure>
<h2 id="2-版本切换"><a href="#2-版本切换" class="headerlink" title="2 版本切换"></a>2 版本切换</h2><p>首先，将已有版本添加到update-alternatives中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 最后的数值代表该版本的权重参数，越大优先级越高</span></span><br><span class="line"><span class="comment"># gcc</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 100</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 70</span><br><span class="line"></span><br><span class="line"><span class="comment"># g++</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 100</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 70</span><br></pre></td></tr></table></figure>
<p>若想删除某个版本的管理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --remove gcc /usr/bin/gcc-11</span><br></pre></td></tr></table></figure>
<p>手动切换版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config gcc</span><br><span class="line">sudo update-alternatives --config g++</span><br></pre></td></tr></table></figure>
<p><img src="/2024/01/26/gcc-g/g++.png" alt="g++" title="g++ version"></p>
<p>如上图所示，输入相应的id 即可实现不同版本之间的切换。</p>
<p>切换完之后，查看版本是否切换成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看当前版本</span></span><br><span class="line">gcc -v</span><br><span class="line">g++ -v</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发环境搭建</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>g++</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu系统安装显卡驱动、CUDA、cuDNN</title>
    <url>/2024/01/26/Ubuntu-dl-setup/</url>
    <content><![CDATA[<p><strong>本文主要参考</strong><a href="https://zhuanlan.zhihu.com/p/643954422">该文章</a>。</p>
<h2 id="1-安装显卡驱动"><a href="#1-安装显卡驱动" class="headerlink" title="1 安装显卡驱动"></a>1 安装显卡驱动</h2><h3 id="1-1-前期准备"><a href="#1-1-前期准备" class="headerlink" title="1.1 前期准备"></a>1.1 前期准备</h3><p>根据显卡型号在<a href="https://www.nvidia.com/Download/Find.aspx?lang=en-us#">Nvidia 官网</a>下载相应的驱动程序，然后安装必备软件：</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 更新源</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment">## 安装必备软件</span></span><br><span class="line">sudo apt-get install g++</span><br><span class="line">sudo apt-get install gcc</span><br><span class="line">sudo apt-get install make</span><br></pre></td></tr></table></figure>
<h3 id="1-2-禁用默认驱动"><a href="#1-2-禁用默认驱动" class="headerlink" title="1.2 禁用默认驱动"></a>1.2 禁用默认驱动</h3><p>在安装NVIDIA驱动前需要禁止系统自带的显卡驱动 nouveau：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑blacklist.conf 文件</span></span><br><span class="line">sudo vi /etc/modprobe.d/blacklist.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件末尾添加以下内容并保存</span></span><br><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新initramfs，然后重启电脑</span></span><br><span class="line">sudo update-initramfs -u</span><br><span class="line">sudo reboot now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否关闭nouveau，若没有输出，则说明已成功关闭</span></span><br><span class="line">lsmod | grep nouveau</span><br></pre></td></tr></table></figure>
<h3 id="1-3-安装驱动"><a href="#1-3-安装驱动" class="headerlink" title="1.3 安装驱动"></a>1.3 安装驱动</h3><p>进入tty 模式，并关闭图形进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service gdm3 stop</span><br></pre></td></tr></table></figure>
<p>开始安装驱动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 赋予执行权限</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 777 NVIDIA-Linux-x86_64-535.54.03.run</span><br><span class="line"><span class="comment">## 安装：不安装OpenGL,安装时关闭X服务  </span></span><br><span class="line">sudo ./NVIDIA-Linux-x86_64-535.54.03.run –no-opengl-files -no-x-check</span><br><span class="line"><span class="comment">## Install Nvidia&#x27;s 32-bit compatibility libraries?</span></span><br><span class="line"><span class="comment">## 选择 &quot;No&quot;</span></span><br><span class="line"><span class="comment">## Would you like to run the nvidia-xconfig utility to automatically update your X configuration file so that the NVIDIA X driver dill be used dhen you restart X? Any pre-existing X configuration file will be backed up.</span></span><br><span class="line"><span class="comment">## 选择 &quot;Yes&quot;</span></span><br></pre></td></tr></table></figure>
<p>成功安装之后，会进入图形界面，此时使用命令nvidia-smi 检查驱动是否安装成功，若出现下图界面，证明驱动安装成功。</p>
<p><img src="/2024/01/26/Ubuntu-dl-setup/nvidia-smi.png" alt="nvidia-smi" title="nvidia-smi显示界面"></p>
<h3 id="1-4-显卡驱动失效问题记录"><a href="#1-4-显卡驱动失效问题记录" class="headerlink" title="1.4 显卡驱动失效问题记录"></a>1.4 显卡驱动失效问题记录</h3><p>一次重启电脑后，发现Ubuntu提示某个文件发生错误，是否需要反馈给Ubuntu，本人当时没在意点了“否”，在后续操作过程中发现nvidia-smi命令报错，显示找不到显卡驱动：</p>
<blockquote>
<p>NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running.</p>
</blockquote>
<p>但使用nvcc -V 命令可以正常显示CUDA 版本。由于之前也遇到过类似驱动失效的问题，所以选择重装显卡驱动，按照之前的步骤检查nouveau、关闭图形界面、安装驱动……然后就一路报错了……</p>
<blockquote>
<p>NVIDIA-SMI has failed because it couldn‘t communicate with the NVIDIA driver.</p>
</blockquote>
<p>网上找解决方案，这篇<a href="https://blog.csdn.net/wjinjie/article/details/108997692">文章</a>提到一个解决方案，使用dkms：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 首先，查看显卡驱动版本</span></span><br><span class="line"><span class="built_in">ls</span> /usr/src | grep nvidia</span><br><span class="line">nvidia-535.146.02</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 然后，安装dkms，并修复显卡驱动</span></span><br><span class="line">sudo apt-get install dkms</span><br><span class="line">sudo dkms install -m nvidia -v 535.146.02</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 输入nvidia-smi命令，一切恢复正常</span></span><br></pre></td></tr></table></figure>
<p>然后搜了一下dkms的作用，wikipedia 中介绍如下：</p>
<blockquote>
<p>动态内核模块支持 （Dynamic Kernel Module Support，DKMS）是用来生成Linux的内核模块的一个框架，其源代码一般不在Linux内核源代码树。 当新的内核安装时，DKMS 支持的内核设备驱动程序 到时会自动重建。 DKMS 可以用在两个方向：如果一个新的内核版本安装，自动编译所有的模块，或安装新的模块（驱动程序）在现有的系统版本上，而不需要任何的手动编译或预编译软件包需要。例如，这使得新的显卡可以使用在旧的Linux系统上。</p>
</blockquote>
<p>唔……很奇怪，我应该没有更新Ubuntu的内核，不晓得为什么会出现这个情况，先记录一下吧，当前本人的Ubuntu内核版本为：</p>
<blockquote>
<p>Linux echo-dell 6.5.0-14-generic #14~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Nov 20 18:15:30 UTC 2 x86_64 x86_64 x86_64 GNU/Linux</p>
</blockquote>
<h2 id="2-安装CUDA"><a href="#2-安装CUDA" class="headerlink" title="2 安装CUDA"></a>2 安装CUDA</h2><h3 id="2-1-下载与安装"><a href="#2-1-下载与安装" class="headerlink" title="2.1 下载与安装"></a>2.1 下载与安装</h3><p>可同时安装不同的CUDA 版本，根据不同环境需求选择使用不同版本，本处以CUDA-11.8为例进行安装说明。</p>
<p>在<a href="https://developer.nvidia.com/cuda-toolkit-archive">NVIDIA官网</a>下载对应版本，推荐使用runfile (local) 进行安装：</p>
<p><img src="/2024/01/26/Ubuntu-dl-setup/CUDA.png" alt="cuda" title="CUDA安装命令"></p>
<p>根据官网给出的下载和安装命令执行即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.8.0/local_installers/cuda_11.8.0_520.61.05_linux.run</span><br><span class="line">sudo sh cuda_11.8.0_520.61.05_linux.run</span><br></pre></td></tr></table></figure>
<h3 id="2-2-环境变量配置"><a href="#2-2-环境变量配置" class="headerlink" title="2.2 环境变量配置"></a>2.2 环境变量配置</h3><p>安装完成后，打开账户的配置文件，进行以下修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## CUDA ENV</span></span><br><span class="line"><span class="built_in">export</span> CUDA_HOME=/usr/local/cuda</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$&#123;LD_LIBRARY_PATH&#125;</span>:<span class="variable">$&#123;CUDA_HOME&#125;</span>/lib64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;CUDA_HOME&#125;</span>/bin:<span class="variable">$&#123;PATH&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新配置文件设置</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装是否成功</span></span><br><span class="line">nvcc -V</span><br></pre></td></tr></table></figure>
<p>若出现下图界面，则证明CUDA 安装成功:</p>
<p><img src="/2024/01/26/Ubuntu-dl-setup/nvcc.png" alt="cuda" title="检验CUDA安装成功"></p>
<h3 id="2-3-多版本切换"><a href="#2-3-多版本切换" class="headerlink" title="2.3 多版本切换"></a>2.3 多版本切换</h3><p>CUDA 安装位置的文件如下图所示：</p>
<p><img src="/2024/01/26/Ubuntu-dl-setup/CUDA-version.png" alt="cuda-version" title="CUDA版本切换"></p>
<p>根据所需版本，切换cuda 的软链接即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -snf /usr/local/cuda-11.8 /usr/local/cuda</span><br></pre></td></tr></table></figure>
<h2 id="3-安装cuDNN"><a href="#3-安装cuDNN" class="headerlink" title="3 安装cuDNN"></a>3 安装cuDNN</h2><p>注：此处可参考<a href="https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html#verify">NVIDIA官网教程</a>进行安装。</p>
<h3 id="3-1-前期准备与下载"><a href="#3-1-前期准备与下载" class="headerlink" title="3.1 前期准备与下载"></a>3.1 前期准备与下载</h3><p>首先安装依赖包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install zlib1g</span><br></pre></td></tr></table></figure>
<p>然后在<a href="https://developer.nvidia.com/rdp/cudnn-download">NVIDIA官网</a>下载相应版本的安装包，注意，下载cuDNN 需要注册NVIDIA账号。选取合适的版本进行下载：</p>
<p><img src="/2024/01/26/Ubuntu-dl-setup/cudnn.png" alt="cudnn" title="cuDNN安装包"></p>
<h3 id="3-2-安装"><a href="#3-2-安装" class="headerlink" title="3.2 安装"></a>3.2 安装</h3><p>解压并安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i cudnn-local-repo-ubuntu2204-8.9.3.28_1.0-1_amd64.deb</span><br></pre></td></tr></table></figure>
<p>按照提示导入CUDA GPG key：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /var/cudnn-local-repo-ubuntu2204-8.9.3.28/cudnn-local-*-keyring.gpg /usr/share/keyrings/</span><br></pre></td></tr></table></figure>
<p>更新源并安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment">## 1. Install the runtime library.</span></span><br><span class="line"><span class="comment">## sudo apt-get install libcudnn8=8.x.x.x-1+cudaX.Y</span></span><br><span class="line">sudo apt-get install libcudnn8=8.9.3.28-1+cuda11.8</span><br><span class="line"><span class="comment">## 2. Install the developer library.</span></span><br><span class="line"><span class="comment">## sudo apt-get install libcudnn8-dev=8.x.x.x-1+cudaX.Y</span></span><br><span class="line">sudo apt-get install libcudnn8-dev=8.9.3.28-1+cuda11.8</span><br><span class="line"><span class="comment">## 3. Install the code samples.</span></span><br><span class="line"><span class="comment">## sudo apt-get install libcudnn8-samples=8.x.x.x-1+cudaX.Y</span></span><br><span class="line">sudo apt-get install libcudnn8-samples=8.9.3.28-1+cuda11.8</span><br></pre></td></tr></table></figure>
<h3 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h3><p>输入检查命令，出现下图证明安装初步成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -l | grep cudnn</span><br></pre></td></tr></table></figure>
<p><img src="/2024/01/26/Ubuntu-dl-setup/cudnn-dpkg.png" alt="cudnn-version" title="cuDNN安装成功"></p>
<p>按照官网教程，进行代码测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将cuDNN samples 拷贝至主目录</span></span><br><span class="line"><span class="built_in">cp</span> -r /usr/src/cudnn_samples_v8/ <span class="variable">$HOME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入samples 文件夹，并编译</span></span><br><span class="line"><span class="built_in">cd</span>  <span class="variable">$HOME</span>/cudnn_samples_v8/mnistCUDNN</span><br><span class="line">make clean &amp;&amp; make</span><br></pre></td></tr></table></figure>
<p>此时可能出现如下报错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fatal error: FreeImage.h: No such file <span class="keyword">or</span> directory</span><br><span class="line">    <span class="number">1</span> | <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeImage.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/01/26/Ubuntu-dl-setup/cudnn-error.png" alt="cudnn-error" title="cuDNN报错"></p>
<p>可安装相应包进行解决：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libfreeimage3 libfreeimage-dev</span><br></pre></td></tr></table></figure>
<p>安装之后重新编译，并运行生成文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新编译</span></span><br><span class="line">make clean &amp;&amp; make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行生成文件</span></span><br><span class="line">./mnistCUDNN</span><br></pre></td></tr></table></figure>
<p>若出现如下结果，则证明cuDNN 安装成功：</p>
<p><img src="/2024/01/26/Ubuntu-dl-setup/cudnn-success.png" alt="cudnn-success" title="cuDNN安装成功"></p>
]]></content>
      <categories>
        <category>开发环境搭建</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Deep Learning</tag>
        <tag>Nvidia</tag>
        <tag>CUDA</tag>
        <tag>cuDNN</tag>
      </tags>
  </entry>
  <entry>
    <title>寒武纪MLU220 开发环境Docker搭建</title>
    <url>/2024/01/26/mlu220/</url>
    <content><![CDATA[<p>首先进入<a href="https://cair.cambricon.com/#/home/catalog">寒武纪开发主页</a>并登录寒武纪账号，进入cambricon_pytorch docker 页面。由于本人只使用MLU220 进行边缘端推理，所以不需要在主机上安装MLU 驱动，因此可跳过第一步直接按照提示安装docker。本人在尝试按照页面说明时遇到了一些问题，在此记录一下。</p>
<span id="more"></span>
<p>若是初次使用docker，则建议将Ubuntu个人账户添加进docker组里，这样就避免每次使用时都要输入sudo了，该部分参考<a href="https://www.cnblogs.com/jzcn/p/16591083.html">文章</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 将当前用户添加进docker组，并更新</span><br><span class="line">sudo gpasswd -a user docker</span><br><span class="line">newgrp docker</span><br><span class="line"></span><br><span class="line">## 然后重启电脑才可永久生效</span><br></pre></td></tr></table></figure>
<p>然后按照寒武纪提示，依次进行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 登录harbor</span><br><span class="line">docker login cair.cambricon.com</span><br><span class="line"></span><br><span class="line">## 输入用户名、API密钥（网页用户名下拉框中有API密钥选项）</span><br><span class="line">Username: (username)</span><br><span class="line">Password: (API密钥)</span><br></pre></td></tr></table></figure>
<p>注意，这里网页提示使用docker pull命令下载相应的镜像文件，但经过本人尝试之后发现，在后续的docker run命令中会重复下载，因此<strong>跳过使用docker pull，直接使用docker run命令创建容器</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --name mlu220 -v /home/***/work:/work cair.cambricon.com/cambricon/cambricon_pytorch:ubuntu18.04_sdk_v1.7.0_pytorch_v0.15.0-2 /bin/bash</span><br></pre></td></tr></table></figure>
<p>上述命令会自动下载镜像文件，并改名为“mlu220”，且将主机的“/home/<em>*</em>/work”映射至docker端的“/work”。</p>
<p>此时，可以查看新建的容器：</p>
<p><img src="/2024/01/26/mlu220/docker1.png" alt="docker" title="容器查看"></p>
<p>启动mlu220容器并查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ docker start mlu220</span><br><span class="line">mlu220</span><br></pre></td></tr></table></figure>
<p><img src="/2024/01/26/mlu220/docker2.png" alt="docker" title="启动容器"></p>
<p>最后进入docker并激活开发环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mlu220 /bin/bash</span><br><span class="line"><span class="built_in">source</span> torch/venv3/pytorch/bin/activate</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发环境搭建</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Cambricon</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Object SLAM部署过程</title>
    <url>/2024/01/26/object-slam/</url>
    <content><![CDATA[<p>系统代码包下载地址为<a href="https://github.com/yangliu9527/Object_SLAM.git">github地址</a>，论文为(Liu 等, 2023).</p>
<h2 id="1-ORB-SLAM2基础问题"><a href="#1-ORB-SLAM2基础问题" class="headerlink" title="1 ORB-SLAM2基础问题"></a>1 ORB-SLAM2基础问题</h2><p>该算法是在ORB-SLAM2 的基础上进行改进的，编译过程可参考ORB-SLAM2的部署教程，此处不再赘述。除此之外，本人在部署过程中还遇到了其他问题，这里记录一下。</p>
<span id="more"></span>
<h2 id="2-其他问题"><a href="#2-其他问题" class="headerlink" title="2 其他问题"></a>2 其他问题</h2><ul>
<li>PCL 报错：</li>
</ul>
<blockquote>
<p>error: #error PCL requires C++14 or above</p>
</blockquote>
<p>参考这篇<a href="https://blog.csdn.net/handily_1/article/details/122421305">文章</a>解释，使用C++14编译器，更改主目录下的CMakeLists.txt：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">### 修改前</span><br><span class="line"># Check C++<span class="number">11</span> <span class="keyword">or</span> C++<span class="number">0</span><span class="function">x support</span></span><br><span class="line"><span class="function"><span class="title">include</span><span class="params">(CheckCXXCompilerFlag)</span></span></span><br><span class="line"><span class="function"><span class="title">CHECK_CXX_COMPILER_FLAG</span><span class="params">(<span class="string">&quot;-std=c++11&quot;</span> COMPILER_SUPPORTS_CXX11)</span></span></span><br><span class="line"><span class="function"><span class="title">CHECK_CXX_COMPILER_FLAG</span><span class="params">(<span class="string">&quot;-std=c++0x&quot;</span> COMPILER_SUPPORTS_CXX0X)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(COMPILER_SUPPORTS_CXX11)</span></span></span><br><span class="line"><span class="function">   <span class="title">set</span><span class="params">(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;</span>)</span></span></span><br><span class="line"><span class="function">   <span class="title">add_definitions</span><span class="params">(-DCOMPILEDWITHC11)</span></span></span><br><span class="line"><span class="function">   <span class="title">message</span><span class="params">(STATUS <span class="string">&quot;Using flag -std=c++11.&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">### 修改后</span></span><br><span class="line"><span class="function"># Check C++11 <span class="keyword">or</span> C++0x support</span></span><br><span class="line"><span class="function"><span class="title">include</span><span class="params">(CheckCXXCompilerFlag)</span></span></span><br><span class="line"><span class="function"><span class="title">CHECK_CXX_COMPILER_FLAG</span><span class="params">(<span class="string">&quot;-std=c++11&quot;</span> COMPILER_SUPPORTS_CXX11)</span></span></span><br><span class="line"><span class="function"><span class="title">CHECK_CXX_COMPILER_FLAG</span><span class="params">(<span class="string">&quot;-std=c++0x&quot;</span> COMPILER_SUPPORTS_CXX0X)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(COMPILER_SUPPORTS_CXX11)</span></span></span><br><span class="line"><span class="function">   <span class="title">set</span><span class="params">(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++14&quot;</span>)</span></span></span><br><span class="line"><span class="function">   <span class="title">add_definitions</span><span class="params">(-DCOMPILEDWITHC11)</span></span></span><br><span class="line"><span class="function">   <span class="title">message</span><span class="params">(STATUS <span class="string">&quot;Using flag -std=c++14.&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>修改完之后不再报错，可正常编译。</p>
<ul>
<li>针对不同的输入图片，需要设置不同的通道变换方式，否则会报与数据通道相关的错误，如下图所示；修改方法为修改frame.cc 代码 392行附近的内容：</li>
</ul>
<p><img src="/2024/01/26/object-slam/err1.png" alt="err1" title="err1"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//* for gray pictures (e.g. KITTI-odometry dataset)</span></span><br><span class="line">cv::Mat imRGB_1;</span><br><span class="line">cv::<span class="built_in">cvtColor</span>(imRGB.<span class="built_in">clone</span>(), imRGB_1, CV_GRAY2BGR);</span><br><span class="line">cv::<span class="built_in">cvtColor</span>(imRGB_1.<span class="built_in">clone</span>(), Img_HSV, CV_BGR2HSV);</span><br><span class="line"></span><br><span class="line"><span class="comment">//* for RGB pictures (e.g. TUM dataset)</span></span><br><span class="line"><span class="comment">// cv::cvtColor(imRGB.clone(), Img_HSV, CV_BGR2HSV);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在VS Code 里对程序进行调试运行时，可能会报错：</li>
</ul>
<p><img src="/2024/01/26/object-slam/err2.png" alt="err2"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 只有在VS Code 中调试才会出现该错误，解决办法是在VS Code 中unset GTK_PATH即可：</span></span><br><span class="line"><span class="built_in">unset</span> GTK_PATH</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>Object SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Semantic</tag>
        <tag>C++</tag>
        <tag>Object SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>ORB-SLAM2环境搭建与运行</title>
    <url>/2024/01/26/orbslam2-env/</url>
    <content><![CDATA[<p>本文主要参考<a href="https://blog.csdn.net/meng_152634/article/details/127570220">该文章</a>。</p>
<h2 id="1-Eigen3安装与卸载"><a href="#1-Eigen3安装与卸载" class="headerlink" title="1 Eigen3安装与卸载"></a>1 Eigen3安装与卸载</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p>可通过apt命令安装，由于使用源码安装的方式在后续编译ORB-SLAM2 过程中可能会遇到一些问题，因此，本人<strong>建议使用apt命令进行安装</strong>：</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install libeigen3-dev</span><br></pre></td></tr></table></figure>
<p>也可在<a href="https://eigen.tuxfamily.org/index.php?title=Main_Page">官网</a>下载eigen3 源码，然后编译安装（本人不推荐该方法，后续会出现程序找不到eigen3的问题）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> eigen-xxx</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>版本查看命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ pkg-config --modversion eigen3</span><br><span class="line">3.4.0</span><br></pre></td></tr></table></figure>
<h3 id="1-2-卸载"><a href="#1-2-卸载" class="headerlink" title="1.2 卸载"></a>1.2 卸载</h3><p>通过apt 方式安装的采用以下方式进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 通过remove 卸载</span></span><br><span class="line">sudo apt remove libeigen3-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">## 可通过locate 进一步定位残余文件进行手动删除，并手动删除/usr/local/和/usr/include/目录下的eigen目录</span></span><br><span class="line">sudo updatedb</span><br><span class="line">locate eigen</span><br></pre></td></tr></table></figure>
<p>通过源码安装的，需要手动删除/usr/local/include/等目录下的eigen3目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo updatedb</span><br><span class="line">locate eigen3  <span class="comment"># 查看eigen3的位置</span></span><br><span class="line">sudo <span class="built_in">rm</span> -rf /usr/include/eigen3</span><br><span class="line">sudo <span class="built_in">rm</span> -rf /usr/lib/cmake/eigen3</span><br><span class="line">sudo <span class="built_in">rm</span> -rf /usr/local//include/eigen3</span><br><span class="line">sudo <span class="built_in">rm</span> -rf /usr/share/doc/libeigen3-dev</span><br><span class="line">sudo <span class="built_in">rm</span> -rf /usr/local/share/pkgconfig/eigen3.pc /usr/share/pkgconfig/eigen3.pc /var/lib/dpkg/info/libeigen3-dev.list /var/lib/dpkg/info/libeigen3-dev.md5sums</span><br></pre></td></tr></table></figure>
<h2 id="2-Pangolin-安装与卸载"><a href="#2-Pangolin-安装与卸载" class="headerlink" title="2 Pangolin 安装与卸载"></a>2 Pangolin 安装与卸载</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>首先安装依赖项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install libglew-dev</span><br><span class="line">sudo apt install libboost-dev libboost-thread-dev libboost-filesystem-dev</span><br><span class="line">sudo apt install libboost-all-dev</span><br><span class="line">sudo apt install libwayland-dev wayland-protocols</span><br><span class="line">sudo apt install libxkbcommon-dev</span><br><span class="line">sudo apt install libegl1-mesa-dev</span><br><span class="line">sudo apt install ninja-build</span><br></pre></td></tr></table></figure>
<p>然后下载源码，编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/stevenlovegrove/Pangolin.git</span><br><span class="line"></span><br><span class="line"><span class="comment">## 编译安装</span></span><br><span class="line"><span class="built_in">cd</span> Pangolin</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>然后可在/usr/local/include/和/usr/local/lib/目录下找到pangolin相关的目录及库文件：</p>
<p><img src="/2024/01/26/orbslam2-env/pangolin.png" alt="pangolin" title="Pangolin目录及库文件"></p>
<p>安装完成后进行测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Pangolin/build/examples/HelloPangolin/</span><br><span class="line">./HelloPangolin</span><br></pre></td></tr></table></figure>
<p>出现以下界面说明安装成功：</p>
<p><img src="/2024/01/26/orbslam2-env/pangolin-success.png" alt="pangolin success" title="Pangolin安装成功"></p>
<h3 id="2-2-卸载"><a href="#2-2-卸载" class="headerlink" title="2.2 卸载"></a>2.2 卸载</h3><p>Pangolin 的卸载需要手动删除相关文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo updatedb</span><br><span class="line">locate pangolin</span><br><span class="line">sudo <span class="built_in">rm</span> -rf /usr/local/include/pangolin</span><br><span class="line">sudo <span class="built_in">rm</span> /usr/local/lib/libpango_*.so</span><br></pre></td></tr></table></figure>
<h2 id="3-opencv-安装与卸载"><a href="#3-opencv-安装与卸载" class="headerlink" title="3 opencv 安装与卸载"></a>3 opencv 安装与卸载</h2><p>分别到<a href="https://opencv.org/releases/">opencv</a>、<a href="https://github.com/opencv/opencv_contrib/tags">contrib</a> 开发库下载对应版本，注意，两个文件的版本需要保持一致。</p>
<h3 id="3-0-pkg-config"><a href="#3-0-pkg-config" class="headerlink" title="3.0 pkg-config"></a>3.0 pkg-config</h3><h4 id="3-0-1-介绍"><a href="#3-0-1-介绍" class="headerlink" title="3.0.1 介绍"></a>3.0.1 介绍</h4><p>opencv 多版本管理主要参考<a href="https://www.cntofu.com/book/46/opencv/ubuntuxia_duo_ban_ben_opencv_qie_huan.md">文章1</a>和<a href="https://ivanzz1001.github.io/records/post/linux/2017/09/08/linux-pkg-config#1-pkg-config简单介绍">文章2</a>，该文章主要利用pkg-config 包管理工具来管理多版本的opencv。</p>
<p>一般用第三方库的时候，就少不了要使用到<strong>第三方的头文件</strong>和<strong>库文件</strong>。我们在编译、链接的时候必须要指定这些头文件和库文件的位置。对于一个比较大的第三方库，其头文件和库文件的数量是比较多的，如果我们一个个手动地写，那将是相当的麻烦的。因此，pkg-config就应运而生了。pkg-config能够把这些头文件和库文件的位置指出来，给编译器使用。pkg-config主要提供了下面几个功能：</p>
<ul>
<li>检查库的版本号。 如果所需要的库的版本不满足要求，它会打印出错误信息，避免链接错误版本的库文件</li>
<li>获得编译预处理参数，如宏定义、头文件的位置</li>
<li>获得链接参数，如库及依赖的其他库的位置，文件名及其他一些链接参数</li>
<li>自动加入所依赖的其他库的设置</li>
</ul>
<p>如以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c `pkg-config --libs --cflags glib-2.0`</span><br></pre></td></tr></table></figure>
<p>其中，—libs 用于指定<strong>库文件</strong>，—cflags 用于指定<strong>头文件</strong>。</p>
<p>pkg-config 命令基本用法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg-config &lt;options&gt; &lt;library-name&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-0-2-配置环境变量"><a href="#3-0-2-配置环境变量" class="headerlink" title="3.0.2 配置环境变量"></a>3.0.2 配置环境变量</h4><p>事实上，pkg-config只是一个工具，所以不是你安装了一个第三方库，pkg-config就能知道第三方库的头文件和库文件的位置的。为了让pkg-config可以得到一个库的信息，就要求库的提供者提供一个<strong>.pc 文件</strong>。例如，本人安装的opencv-4.6.0 中包含了对应的opencv4.pc 文件：</p>
<p><img src="/2024/01/26/orbslam2-env/opencv4.png" alt="opencv4" title="opencv4.pc"></p>
<p>首先，将.pc 文件拷贝至pkgconfig 路径下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> ~/Softwares/opencv/opencv-4.6.0/lib/pkgconfig/opencv4.pc /usr/lib/pkgconfig/opencv4.pc</span><br></pre></td></tr></table></figure>
<p>然后，添加链接库路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 新建文件并编辑</span></span><br><span class="line">sudo vi /etc/ld.so.conf.d/opencv4.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加链接库路径</span></span><br><span class="line">/home/echo/Softwares/opencv/opencv-4.6.0/lib/</span><br><span class="line"></span><br><span class="line"><span class="comment">## 刷新</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<p>刷新之后，即可检验相应版本是否添加成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; pkg-config --modversion opencv4</span><br><span class="line">4.6.0</span><br></pre></td></tr></table></figure>
<p><img src="/2024/01/26/orbslam2-env/opencv4-1.png" alt="opencv4" title="opencv4库文件与头文件"></p>
<p>相应地，编译工程时即可使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -o cv_test cv_test.cpp `pkg-config --libs --cflags opencv4`</span><br></pre></td></tr></table></figure>
<h3 id="3-1-opencv-4-6-0"><a href="#3-1-opencv-4-6-0" class="headerlink" title="3.1 opencv-4.6.0"></a>3.1 opencv-4.6.0</h3><h4 id="3-1-1-编译与安装"><a href="#3-1-1-编译与安装" class="headerlink" title="3.1.1 编译与安装"></a>3.1.1 编译与安装</h4><p>编译命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE \</span><br><span class="line">	-D CMAKE_INSTALL_PREFIX=/home/***/Softwares/opencv/opencv-4.6.0 \ <span class="comment">## 更换为相应位置</span></span><br><span class="line">	-D INSTALL_C_EXAMPLES=OFF \</span><br><span class="line">	-D OPENCV_ENABLE_NONFREE=ON \</span><br><span class="line">	-D WITH_CUDA=ON \</span><br><span class="line">	-D WITH_CUDNN=ON \</span><br><span class="line">	-D OPENCV_DNN_CUDA=ON \</span><br><span class="line">	-D ENABLE_FAST_MATH=1 \</span><br><span class="line">	-D CUDA_FAST_MATH=1 \</span><br><span class="line">	-D CUDA_ARCH_BIN=8.6 \  <span class="comment">## 一定更改为显卡对应的算力版本</span></span><br><span class="line">	-D WITH_CUBLAS=1 \</span><br><span class="line">	-D OPENCV_EXTRA_MODULES_PATH=/home/***/Softwares/opencv/opencv-4.6.0/opencv_contrib/modules \</span><br><span class="line">	-D BUILD_EXAMPLES=ON ..</span><br></pre></td></tr></table></figure>
<p>因为要使用pkg-config 对不同版本的opencv 进行管理，但是<strong>opencv4默认将opencv.pc 的产生选项关闭了</strong>，查看CMakelist.txt 相关语句如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OCV_OPTION(OPENCV_GENERATE_PKGCONFIG <span class="string">&quot;Generate .pc file for pkg-config build tool (deprecated)&quot;</span> OFF)</span><br></pre></td></tr></table></figure>
<p>所以需将CMakelist.txt 中对应语句的<strong>参数改为ON</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 将对应命令更改如下：</span></span><br><span class="line">OCV_OPTION(OPENCV_GENERATE_PKGCONFIG <span class="string">&quot;Generate .pc file for pkg-config build tool (deprecated)&quot;</span> ON)</span><br></pre></td></tr></table></figure>
<p>编译成功之后，make、安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j13 -w</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>值得注意的是，由于是安装到了自定义目录下，在利用CMakeLists.txt 进行编译前，需要进行以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 将build文件夹中的OpenCVConfig.cmake、OpenCVModules.cmake移至share/opencv4中</span></span><br><span class="line">sudo <span class="built_in">cp</span> OpenCVConfig.cmake OpenCVModules.cmake ../../share/opencv4/</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改CMakeLists.txt 文件，设置搜寻路径</span></span><br><span class="line"><span class="built_in">set</span>(OpenCV_DIR /home/echo/Softwares/opencv/opencv-4.6.0/share/opencv4)</span><br><span class="line">find_package(OpenCV)</span><br></pre></td></tr></table></figure>
<h4 id="3-1-2-多版本控制"><a href="#3-1-2-多版本控制" class="headerlink" title="3.1.2 多版本控制"></a>3.1.2 多版本控制</h4><p>按照pkgconfig  版本控制，使用opencv-4.6.0 对自带的示例进行测试，修改CMakeLists.txt 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 设置搜寻路径</span></span><br><span class="line"><span class="built_in">set</span>(OpenCV_DIR /home/echo/Softwares/opencv/opencv-4.6.0/share/opencv4)</span><br><span class="line">find_package(OpenCV)</span><br></pre></td></tr></table></figure>
<p>进行cmake编译并执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmake 过程中会出现相应的版本号、库文件等信息</span></span><br><span class="line">cmake .</span><br><span class="line">make</span><br><span class="line">./opencv_example</span><br></pre></td></tr></table></figure>
<p>得到如下输出结果，证明安装成功：</p>
<p><img src="/2024/01/26/orbslam2-env/opencv4-success.png" alt="opencv-success" title="opencv安装成功"></p>
<p>同样地，使用g++ 命令进行编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -o opencv_example example.cpp `pkg-config --libs --cflags opencv4`</span><br></pre></td></tr></table></figure>
<p>执行生成文件，得到与上图相同的结果证明安装成功。</p>
<h3 id="3-2-opencv-3-4-11"><a href="#3-2-opencv-3-4-11" class="headerlink" title="3.2 opencv-3.4.11"></a>3.2 opencv-3.4.11</h3><p>编译命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE \</span><br><span class="line">	-D CMAKE_INSTALL_PREFIX=/home/***/Softwares/opencv/opencv-3.4.11 \</span><br><span class="line">	-D INSTALL_C_EXAMPLES=OFF \</span><br><span class="line">	-D OPENCV_ENABLE_NONFREE=ON \</span><br><span class="line">	-D WITH_CUDA=ON \</span><br><span class="line">	-D WITH_CUDNN=ON \</span><br><span class="line">	-D OPENCV_DNN_CUDA=ON \</span><br><span class="line">	-D ENABLE_FAST_MATH=1 \</span><br><span class="line">	-D CUDA_FAST_MATH=1 \</span><br><span class="line">	-D CUDA_ARCH_BIN=8.6 \</span><br><span class="line">	-D WITH_CUBLAS=1 \</span><br><span class="line">	-D OPENCV_EXTRA_MODULES_PATH=/home/***/Softwares/opencv/opencv-3.4.11/opencv_contrib/modules \</span><br><span class="line">	-D BUILD_EXAMPLES=ON ..</span><br></pre></td></tr></table></figure>
<p>该版本的opencv 会自动在share/OpenCV 文件夹下生成OpenCVConfig.cmake、OpenCVModules.cmake 等文件，所以无需从build 文件夹中进行复制。</p>
<p>其他使用pkg-config 进行多版本控制方法与opencv-4.6.0 一致，在此不做赘述。</p>
<h3 id="3-3-opencv-卸载"><a href="#3-3-opencv-卸载" class="headerlink" title="3.3 opencv 卸载"></a>3.3 opencv 卸载</h3><p>首先，到编译目录build 下执行卸载命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make uninstall</span><br></pre></td></tr></table></figure>
<p>然后，到opencv 的安装目录下，将bin、lib、share、include 等文件删除即可。若不再安装本版本，则将pkg-config 的相关配置清除掉。</p>
<h2 id="4-ORB-SLAM2-编译与运行"><a href="#4-ORB-SLAM2-编译与运行" class="headerlink" title="4 ORB-SLAM2 编译与运行"></a>4 ORB-SLAM2 编译与运行</h2><h3 id="4-1-前期准备"><a href="#4-1-前期准备" class="headerlink" title="4.1 前期准备"></a>4.1 前期准备</h3><p>在此注明一下本人各个软件包的<strong>最终版本</strong>如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opencv: 3.4.11</span><br><span class="line">eigen3: 3.4.0</span><br><span class="line">pabgolin: 0.6</span><br></pre></td></tr></table></figure>
<p>明确完软件包版本后，首先到<a href="https://github.com/raulmur/ORB_SLAM2">ORB-SLAM2仓库</a>下载，进入下载的文件夹后对以下文件进行更改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 对主目录及DBoW2下的CMakeLists.txt 文件中的opencv版本及搜寻路径进行相应修改</span></span><br><span class="line"><span class="built_in">set</span>(OpenCV_DIR /home/echo/Softwares/opencv/opencv-3.4.11/share/OpenCV)</span><br><span class="line">find_package(OpenCV 3.4.11 QUIET)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 对主目录下的CMakeLists.txt 文件中的eigen3 版本进行修改</span></span><br><span class="line">find_package(Eigen3 3.4.0 REQUIRED)</span><br></pre></td></tr></table></figure>
<h3 id="4-2-编译"><a href="#4-2-编译" class="headerlink" title="4.2 编译"></a>4.2 编译</h3><p>按照官方介绍进行编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x build.sh</span><br><span class="line">./build.sh</span><br></pre></td></tr></table></figure>
<p>正常编译成功的话会在<em>lib</em> 文件夹内生成<strong>libORB_SLAM2.so</strong> 函数库，在<em>Examples</em> 文件夹内生成对应的可执行文件：<strong>mono_tum, mono_kitti, rgbd_tum, stereo_kitti, mono_euroc</strong> 和 <strong>stereo_euroc</strong>。但一般都会有各种报错，这里记录一下本人的报错及相应处理。</p>
<ul>
<li>首先是可能因为软件包版本问题报错：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 报错内容：</span></span><br><span class="line">Pangolin could not be found because dependency Eigen3 could not be found</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 解决方案：</span></span><br><span class="line">根据网上找的资料，可能是Pangolin和Eigen3的版本问题；按照网上教程，卸载了Pangolin和Eigen3，由于要手动选取版本，所以这里Eigen3选择了源文件安装，但后续又出现了其他问题，故又卸载新安装的Eigen3，重新使用apt安装了Eigen3，所以最终情况是：Pangolin降级为v0.6，Eigen3仍是原来的3.4.0。至此，该问题得到解决</span><br></pre></td></tr></table></figure>
<ul>
<li>再次编译可能会出现<strong>无法找到Eigen3 函数库</strong>的报错，此时根据报错内容，将Eigen3 的安装位置：/usr/include/目录下的eigen目录软链接到相应位置即可。</li>
<li>过程中没有其他报错内容，DBoW2、g2o等均编译成功，但最终编译ORB-SLAM2 各个运行程序时会提示：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 输出提示</span></span><br><span class="line">make: *** No targets specified and no makefile found.  Stop.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 在ORB-SLAM2的issues中找到解决方案：</span></span><br><span class="line"><span class="comment">## 删掉build文件，直接执行build.sh中的最后一步</span></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<ul>
<li>出现usleep() 未声明的报错：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">## 报错内容：</span><br><span class="line">error: ‘usleep’ was <span class="keyword">not</span> declared in <span class="keyword">this</span> scope</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 解决方案：在system.h文件中加入</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>LoopClosing.h中的报错：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">## 报错内容：</span><br><span class="line">/usr/include/c++/<span class="number">9</span>/bits/stl_map.h: In instantiation of ‘<span class="keyword">class</span> <span class="title class_">std</span>::map&lt;ORB_SLAM2::KeyFrame*, g2o::Sim3, std::less&lt;ORB_SLAM2::KeyFrame*&gt;, Eigen::aligned_allocator&lt;std::pair&lt;<span class="type">const</span> ORB_SLAM2::KeyFrame*, g2o::Sim3&gt; &gt; &gt;’:</span><br><span class="line">ORB_SLAM2/src/LoopClosing.cc:<span class="number">438</span>:<span class="number">21</span>: required from here</span><br><span class="line">/usr/include/c++/<span class="number">9</span>/bits/stl_map.h:<span class="number">122</span>:<span class="number">71</span>: error: <span class="type">static</span> assertion failed: std::map must have the same value_type as its allocator</span><br><span class="line"><span class="number">122</span> | <span class="built_in">static_assert</span>(is_same&lt;<span class="keyword">typename</span> _Alloc::value_type, value_type&gt;::value,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 解决方案：</span><br><span class="line">修改LoopClosing.h文件中的<span class="number">49</span>和<span class="number">50</span>行：</span><br><span class="line">修改前：</span><br><span class="line"><span class="keyword">typedef</span> map&lt;KeyFrame*,g2o::Sim3,std::less&lt;KeyFrame*&gt;,</span><br><span class="line">        Eigen::aligned_allocator&lt;std::pair&lt;<span class="type">const</span> KeyFrame*, g2o::Sim3&gt; &gt; &gt; KeyFrameAndPose;</span><br><span class="line">修改后：</span><br><span class="line"><span class="keyword">typedef</span> map&lt;KeyFrame*,g2o::Sim3,std::less&lt;KeyFrame*&gt;,</span><br><span class="line">       Eigen::aligned_allocator&lt;std::pair&lt;KeyFrame *<span class="type">const</span>, g2o::Sim3&gt; &gt; &gt; KeyFrameAndPose;</span><br></pre></td></tr></table></figure>
<p>至此，安装成功，生成了相应的可执行文件。</p>
<h3 id="4-3-运行测试"><a href="#4-3-运行测试" class="headerlink" title="4.3 运行测试"></a>4.3 运行测试</h3><p>本处使用了TUM RGB-D 数据集进行测试，测试命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./Examples/RGB-D/rgbd_tum Vocabulary/ORBvoc.txt Examples/RGB-D/TUM1.yaml ~/datasets/TUM/rgbd_dataset_freiburg1_desk ~/datasets/TUM/rgbd_dataset_freiburg1_desk/associate.txt </span><br></pre></td></tr></table></figure>
<p>运行界面如下图所示：</p>
<p><img src="/2024/01/26/orbslam2-env/orbslam2-success.png" alt="orbslam2" title="ORB-SLAM2成功运行"></p>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>ORB-SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>C++</tag>
        <tag>Ubuntu</tag>
        <tag>ORB-SLAM2</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH免密登录设置</title>
    <url>/2024/01/26/ssh-setup/</url>
    <content><![CDATA[<h1 id="1-ssh服务"><a href="#1-ssh服务" class="headerlink" title="1 ssh服务"></a>1 ssh服务</h1><p>Ubuntu开启ssh服务需要下载openssh-server，命令为：</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>
<h1 id="2-ssh-key生成"><a href="#2-ssh-key生成" class="headerlink" title="2 ssh key生成"></a>2 ssh key生成</h1><p>生成ssh key的命令是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p>后续一路默认设置即可，该命令会在主目录默认生成.ssh文件，内包含以下文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">id_rsa: 私钥</span><br><span class="line">id_rsa.pub: 公钥</span><br></pre></td></tr></table></figure>
<h1 id="3-无密码远程登陆服务器"><a href="#3-无密码远程登陆服务器" class="headerlink" title="3 无密码远程登陆服务器"></a>3 无密码远程登陆服务器</h1><p>将本地产生的公钥上传至服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -p <span class="comment">#port master@ubuntu</span></span><br></pre></td></tr></table></figure>
<h1 id="4-Windows免密登录Ubuntu"><a href="#4-Windows免密登录Ubuntu" class="headerlink" title="4 Windows免密登录Ubuntu"></a>4 Windows免密登录Ubuntu</h1><p>Windows在终端中执行以下命令生成公私密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>会在C:\Users\xxx.ssh 文件夹中生成以下三个文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">id_rsa 本地私钥</span><br><span class="line">id_rsa.pub 公钥</span><br><span class="line">known_hosts 已知的ip</span><br></pre></td></tr></table></figure>
<p>将公钥上传至Ubuntu，可使用scp命令，然后执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将公钥拷贝至Ubuntu的authorized_keys文件中</span></span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改sshd_config文件</span></span><br><span class="line">sudo vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一下三行命令添加至sshd_config文件</span></span><br><span class="line">RSAAuthentication <span class="built_in">yes</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br><span class="line">PasswordAuthentication no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启ssh</span></span><br><span class="line">sudo service sshd restart</span><br></pre></td></tr></table></figure>
<p>然后即可实现Windows免密登录Ubuntu。</p>
]]></content>
      <categories>
        <category>开发环境搭建</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh、Oh-My-Zsh及相关设置</title>
    <url>/2024/01/26/zsh-setup/</url>
    <content><![CDATA[<p>注：<strong>本文主要参考</strong><a href="https://www.kwchang0831.dev/dev-env/ubuntu/oh-my-zsh">该文章</a>。</p>
<h1 id="1-安装并设置zsh"><a href="#1-安装并设置zsh" class="headerlink" title="1 安装并设置zsh"></a>1 安装并设置zsh</h1><p>安装命令：</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure>
<p>设置zsh为默认shell：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s $(<span class="built_in">which</span> zsh)</span><br></pre></td></tr></table></figure>
<h1 id="2-安装Oh-My-Zsh"><a href="#2-安装Oh-My-Zsh" class="headerlink" title="2 安装Oh My Zsh"></a>2 安装Oh My Zsh</h1><p>安装命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="3-安装主题PowerLevel10k"><a href="#3-安装主题PowerLevel10k" class="headerlink" title="3 安装主题PowerLevel10k"></a>3 安装主题PowerLevel10k</h1><p>安装命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/romkatv/powerlevel10k.git <span class="variable">$ZSH_CUSTOM</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure>
<p>进入.zshrc设置主题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="4-安装插件"><a href="#4-安装插件" class="headerlink" title="4 安装插件"></a>4 安装插件</h1><h2 id="4-1-日常插件"><a href="#4-1-日常插件" class="headerlink" title="4.1 日常插件"></a>4.1 日常插件</h2><p>zsh-autosuggestions:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>
<p>zsh-syntax-highlighting:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>
<p>设置要启动的插件（Plugins）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">         git</span><br><span class="line">         zsh-autosuggestions </span><br><span class="line">         zsh-syntax-highlighting</span><br><span class="line">         extract</span><br><span class="line">         sudo</span><br><span class="line">         tmux</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>值得注意的是，除了zsh-autosuggestions 与zsh-syntax-highlighting 需要单独安装外，上述的其他插件均是内嵌的，可直接添加至配置文件中直接使用。</p>
<h2 id="4-2-Tmux设置"><a href="#4-2-Tmux设置" class="headerlink" title="4.2 Tmux设置"></a>4.2 Tmux设置</h2><p><strong>该部分主要参考</strong><a href="https://louiszhai.github.io/2017/09/30/tmux/#导读">文章</a>。</p>
<p>安装命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tmux</span><br></pre></td></tr></table></figure>
<p>tmux 的个性化设置需在主目录编辑.tmux.conf 文件，本人的文件设置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g prefix C-z</span><br><span class="line">unbind C-b</span><br><span class="line"><span class="built_in">bind</span> C-a send-prefix</span><br><span class="line"></span><br><span class="line"><span class="built_in">bind</span> r source-file ~/.tmux.conf \; display-message <span class="string">&quot;Config reloaded..&quot;</span></span><br><span class="line"></span><br><span class="line">unbind <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line"><span class="built_in">bind</span> - splitw -v -c <span class="string">&#x27;#&#123;pane_current_path&#125;&#x27;</span></span><br><span class="line">unbind %</span><br><span class="line"><span class="built_in">bind</span> | splitw -h -c <span class="string">&#x27;#&#123;pane_current_path&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">set-option -g mouse on</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -g base-index 0</span><br><span class="line"><span class="built_in">set</span> -g pane-base-index 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># setw -g utf8 on</span></span><br><span class="line"><span class="built_in">set</span> -g status-interval 1</span><br><span class="line"><span class="built_in">set</span> -g status-justify left</span><br><span class="line">setw -g monitor-activity on</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -g status-bg black</span><br><span class="line"><span class="built_in">set</span> -g status-fg yellow</span><br><span class="line"><span class="built_in">set</span> -g status-left <span class="string">&quot;#[bg=#FF661D] ❐ #S &quot;</span></span><br><span class="line"><span class="built_in">set</span> -g status-right <span class="string">&quot;%H:%M:%S %d-%b&quot;</span></span><br><span class="line"><span class="built_in">set</span> -g status-left-length 300</span><br><span class="line"><span class="built_in">set</span> -g status-right-length 500</span><br><span class="line"><span class="built_in">set</span> -wg window-status-current-format <span class="string">&quot; #I:#W#F &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -g message-style <span class="string">&quot;bg=#202529, fg=#91A8BA&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -g default-terminal <span class="string">&quot;screen-256color&quot;</span></span><br></pre></td></tr></table></figure>
<p>其他使用说明可参考上述链接。在oh my zsh 插件中添加了 tmux 后，可以使用如下快捷键：</p>
<p><img src="/2024/01/26/zsh-setup/hotkey.png" alt="hotkey" title="快捷键设置"></p>
]]></content>
      <categories>
        <category>开发环境搭建</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows远程桌面控制ubuntu</title>
    <url>/2024/01/26/win-remote-ubuntu/</url>
    <content><![CDATA[<h2 id="1-Ubuntu设置与软件安装"><a href="#1-Ubuntu设置与软件安装" class="headerlink" title="1 Ubuntu设置与软件安装"></a>1 Ubuntu设置与软件安装</h2><p>首先打开Ubuntu设置，将Sharing-Remote Desktop打开，如下图所示：</p>
<span id="more"></span>
<p><img src="/2024/01/26/win-remote-ubuntu/ubuntu-setting.png" alt="ubuntu-setting" title="Ubuntu远程桌面设置"></p>
<p>然后安装xrdp：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install xrdp</span><br></pre></td></tr></table></figure>
<p>接下来的步骤网上有很多不同的做法，其中<a href="https://zhuanlan.zhihu.com/p/145614559">这篇文章</a>提到需要修改startwm.sh文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/xrdp/startwm.sh</span><br></pre></td></tr></table></figure>
<p><img src="/2024/01/26/win-remote-ubuntu/startwm.png" alt="startwm.sh" title="修改startwm.sh文件"></p>
<p>将最后两行注释掉，即：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 注释掉这两行</span></span><br><span class="line"><span class="comment"># test -x /etc/X11/Xsession &amp;&amp; exec /etc/X11/Xsession</span></span><br><span class="line"><span class="comment"># exec /bin/sh /etc/X11/Xsession</span></span><br></pre></td></tr></table></figure>
<p>然后即可通过win10自带的远程桌面进行连接：</p>
<p><img src="/2024/01/26/win-remote-ubuntu/remote-access.png" alt="remote" title="win10远程桌面"></p>
<p>到目前为止，本人可以在Windows中正常远程控制Ubuntu，且可实现Ubuntu显示和远程控制<strong>同时在线</strong>，即通过远程控制操作Ubuntu，同时另一个屏幕可正常显示Ubuntu界面，且实时显示远程控制的操作。</p>
<h2 id="2-黑屏问题"><a href="#2-黑屏问题" class="headerlink" title="2 黑屏问题"></a>2 黑屏问题</h2><p>但是，在这之后我重新安装了NVIDIA显卡驱动、CUDA、cuDNN，然后就发现远程控制无法进入Ubuntu系统了，点击“连接”后出现一段时间的黑屏后会自动退出。在网上查询了很多案例，有各种五花八门的解决方案，如换一个桌面程序、使用dconf-editor更改配置文件、远程控制与Ubuntu本地无法同时登陆（必须有一方log out）等等，以下是个人尝试的结果：</p>
<ul>
<li>换桌面程序：由于本人安装的是桌面版Ubuntu，故系统自带桌面程序gnome，之前配置远程控制时就受到网上各种五花八门意见的影响，使用了xfce4桌面程序，后来发现完全没必要，而且就在不久前还可以正常远程连接，说明应该不是桌面程序的原因，因此就没有尝试更换桌面程序；</li>
<li>使用dconf-editor更改配置文件：在<a href="https://zhuanlan.zhihu.com/p/345738274">文章</a>中提到，进入dconf-editor后，依次进入“org-&gt;gnome-&gt;desktop-&gt;remote-access”，将 requre-encryption 设为 False，这也是本人在上个系统（Ubuntu20.04）中的操作，但是在本系统（Ubuntu22.04）中没有发现有“remote-access”，故该方法也没有成功；</li>
<li>本地端与远程端无法共存：这个比较简单，本人试着将Ubuntu本地端账户log out，或者使用不同账户进行远程控制，发现仍然失败；但<strong>需要注意的是</strong>，在本人解决远程黑屏问题之后，发现该问题确实是存在的，若本地端或远程端没有log out，那么另一端就无法正常登陆显示界面，这边记录一下；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 修改startwm.sh文件，添加下面几行，仍旧没有解决问题</span></span><br><span class="line"><span class="built_in">unset</span> DBUS_SESSION_BUS_ADDRESS</span><br><span class="line"><span class="built_in">unset</span> XDG_RUNTIME_DIR</span><br><span class="line">. <span class="variable">$HOME</span>/.profile</span><br></pre></td></tr></table></figure>
<p>最后，不知道怎么想起来，尝试把startwm.sh文件中注释掉的两行取消注释，峰回路转、柳暗花明，竟然成了！！！于是，本人最终的startwm.sh文件内容如下所示：</p>
<p><img src="/2024/01/26/win-remote-ubuntu/startwm-1.png" alt="startwm" title="startwm.sh文件最终版"></p>
<h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3 后记"></a>3 后记</h2><p>虽然不知道原因是什么，只知道目前这样子是可行的，但同时也发现无法像安装显卡驱动前那样本地端和远程端同时登陆了，必须要有一端log out，另一端才可正常工作，现做以下记录：</p>
<ul>
<li>使用远程连接桌面后，不能简单地关掉远程桌面：若只是简单地关掉远程桌面后，在本地端可以正常进入账号选择、密码输入界面，输完密码后会显示黑屏；此时，只有重新进入远程桌面，选择log out，本地端方可正常登录。</li>
<li>对于本地端Todesk等远程控制软件：经过本人测试，Todesk 软件若想正常工作需要本地端正常登录，即要求远程端log out，然后本地端log in；那么也就意味着本地端电脑需要连接显示器。</li>
</ul>
]]></content>
      <categories>
        <category>开发环境搭建</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>remote access</tag>
      </tags>
  </entry>
</search>
